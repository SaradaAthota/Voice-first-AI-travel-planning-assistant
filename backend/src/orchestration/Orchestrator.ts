/**
 * Orchestrator
 * 
 * Main orchestration class that coordinates all modules.
 * 
 * This is the SINGLE entry point for processing user messages.
 * 
 * Flow:
 * 1. Load/create conversation context
 * 2. Route user intent
 * 3. Decide tool calls (orchestrator, not LLM)
 * 4. Execute tool calls with logging
 * 5. Compose response (LLM for text, not tools)
 * 6. Apply policy guards
 * 7. Update state and persist
 * 
 * Rules:
 * - Exactly ONE LLM agent (used here for intent + response)
 * - LLM never calls tools directly
 * - All tool calls go through ToolOrchestrator
 * - State is always persisted
 */

import {
  OrchestratorInput,
  OrchestratorOutput,
  ConversationContext,
  ConversationState,
} from './types';
import { ConversationStateManager } from './ConversationStateManager';
import { IntentRouter } from './IntentRouter';
import { ToolOrchestrator } from './ToolOrchestrator';
import { ResponseComposer } from './ResponseComposer';
import { ExplanationComposer } from './ExplanationComposer';
import { PolicyGuards } from './PolicyGuards';
import { getSupabaseClient } from '../db/supabase';
import { POI } from '../mcp-tools/poi-search/types';
import { ItineraryOutput } from '../mcp-tools/itinerary-builder/types';

export class Orchestrator {
  private stateManager: ConversationStateManager;
  private intentRouter: IntentRouter;
  private toolOrchestrator: ToolOrchestrator;
  private responseComposer: ResponseComposer;
  private explanationComposer: ExplanationComposer;
  private policyGuards: PolicyGuards;
  private supabase = getSupabaseClient();

  constructor() {
    this.stateManager = new ConversationStateManager();
    this.intentRouter = new IntentRouter();
    this.toolOrchestrator = new ToolOrchestrator();
    this.responseComposer = new ResponseComposer();
    this.explanationComposer = new ExplanationComposer();
    this.policyGuards = new PolicyGuards();
  }

  /**
   * Process user message through the orchestration pipeline
   * 
   * This is the MAIN method called by the API endpoint.
   */
  async process(input: OrchestratorInput): Promise<OrchestratorOutput> {
    // Step 1: Load or create conversation context
    let context: ConversationContext;
    if (input.tripId) {
      const loaded = await this.stateManager.loadContext(input.tripId);
      if (!loaded) {
        throw new Error(`Trip ${input.tripId} not found`);
      }
      context = loaded;
    } else {
      // New conversation - create context
      context = await this.stateManager.createContext();
    }

    // Step 2: Route user intent
    // LLM is used HERE for intent classification (single LLM agent)
    const intentClassification = await this.intentRouter.classifyIntent(
      input.message,
      context
    );

    // Update context with extracted entities
    if (intentClassification.entities) {
      context = await this.updateContextWithEntities(
        context,
        intentClassification.entities
      );
    }

    // Step 3: Decide tool calls (ORCHESTRATOR decides, not LLM)
    const toolDecisions = this.toolOrchestrator.decideToolCalls(
      context,
      intentClassification.intent
    );

    // Validate tool call decisions
    for (const decision of toolDecisions) {
      const check = this.policyGuards.validateToolCallDecision(decision);
      if (!check.allowed) {
        console.warn(`Policy violation: ${check.reason}`);
        // Continue but log warning
      }
    }

    // Step 4: Execute tool calls (if any)
    const orchestrationResult = await this.toolOrchestrator.executeToolCalls(
      toolDecisions,
      context
    );

    // Step 5: Update state if tool calls changed it
    if (orchestrationResult.nextState) {
      context = await this.stateManager.transitionTo(
        context,
        orchestrationResult.nextState,
        'Tool orchestration completed'
      );
    }

    // Step 6: Handle state transitions based on intent
    context = await this.handleStateTransition(context, intentClassification.intent);

    // Step 7: Compose response
    // LLM is used HERE for response generation (single LLM agent)
    // Tool outputs are provided as context, not generated by LLM
    
    let response;
    
    // Use ExplanationComposer for EXPLAINING state
    if (context.state === ConversationState.EXPLAINING && intentClassification.intent === 'EXPLAIN') {
      // Extract POI from context if available (from itinerary)
      const poi = await this.extractPOIFromContext(context, input.message);
      
      response = await this.explanationComposer.composeExplanation({
        question: input.message,
        context,
        poi,
        constraints: {
          pace: context.preferences.pace,
          // Weather can be added later if available
        },
      });
    } else {
      // Use regular ResponseComposer for other states
      response = await this.responseComposer.composeResponse(
        context,
        orchestrationResult.toolCalls,
        input.message
      );
    }

    // Step 8: Apply policy guards
    const policyCheck = this.policyGuards.validateResponse(
      response,
      context,
      orchestrationResult.toolCalls
    );

    if (!policyCheck.allowed) {
      console.error(`Policy violation: ${policyCheck.reason}`);
      // Return error response instead
      response.text = `I apologize, but I encountered an issue: ${policyCheck.reason}`;
    }

    // Step 9: Save transcript
    await this.saveTranscript(context.tripId!, 'user', input.message);
    await this.saveTranscript(context.tripId!, 'assistant', response.text);

    // Step 10: Update context with last intent and response
    context.lastIntent = intentClassification.intent;
    context.lastResponse = response.text;
    context = await this.stateManager.updateContext(context, {
      lastIntent: intentClassification.intent,
      lastResponse: response.text,
    });

    // Determine state transition for output
    const stateTransition = orchestrationResult.nextState
      ? {
          from: context.state,
          to: orchestrationResult.nextState,
        }
      : undefined;

    return {
      response,
      context,
      toolCalls: orchestrationResult.toolCalls,
      stateTransition,
    };
  }

  /**
   * Extract POI from context (from itinerary if available)
   */
  private async extractPOIFromContext(
    context: ConversationContext,
    question: string
  ): Promise<POI | undefined> {
    if (!context.tripId) {
      return undefined;
    }

    try {
      // Get active itinerary
      const { data: itinerary } = await this.supabase
        .from('itineraries')
        .select('content')
        .eq('trip_id', context.tripId)
        .eq('is_active', true)
        .single();

      if (!itinerary || !itinerary.content) {
        return undefined;
      }

      const itineraryData = itinerary.content as ItineraryOutput;

      // Try to extract POI name from question
      // Simple extraction - can be improved
      const questionLower = question.toLowerCase();
      
      // Search through all days and activities
      for (const day of itineraryData.days) {
        for (const block of Object.values(day.blocks)) {
          if (block) {
            for (const activity of block.activities) {
              const poiNameLower = activity.poi.name.toLowerCase();
              // Check if POI name appears in question
              if (questionLower.includes(poiNameLower) || poiNameLower.includes(questionLower.split(' ')[0])) {
                return activity.poi;
              }
            }
          }
        }
      }

      // If no match, return first POI from first day
      const firstDay = itineraryData.days[0];
      if (firstDay) {
        const firstBlock = firstDay.blocks.morning || firstDay.blocks.afternoon || firstDay.blocks.evening;
        if (firstBlock && firstBlock.activities.length > 0) {
          return firstBlock.activities[0].poi;
        }
      }
    } catch (error) {
      console.error('Error extracting POI from context:', error);
    }

    return undefined;
  }

  /**
   * Update context with entities extracted from intent classification
   */
  private async updateContextWithEntities(
    context: ConversationContext,
    entities: Record<string, any>
  ): Promise<ConversationContext> {
    const updates: Partial<ConversationContext> = {};

    // Update preferences with extracted entities
    if (entities.city) {
      context.preferences.city = entities.city;
      if (!context.collectedFields.includes('city')) {
        context.collectedFields.push('city');
      }
    }

    if (entities.duration) {
      context.preferences.duration = entities.duration;
      if (!context.collectedFields.includes('duration')) {
        context.collectedFields.push('duration');
      }
    }

    if (entities.startDate) {
      context.preferences.startDate = entities.startDate;
      if (!context.collectedFields.includes('startDate')) {
        context.collectedFields.push('startDate');
      }
    }

    if (entities.interests) {
      context.preferences.interests = entities.interests;
    }

    if (entities.pace) {
      context.preferences.pace = entities.pace;
    }

    // Update edit target if editing
    if (entities.editTarget) {
      updates.editTarget = entities.editTarget;
    }

    // Update missing fields
    const required = ['city', 'duration', 'startDate'];
    context.missingFields = required.filter(
      (field) => !context.collectedFields.includes(field)
    );

    return this.stateManager.updateContext(context, {
      preferences: context.preferences,
      collectedFields: context.collectedFields,
      missingFields: context.missingFields,
      ...updates,
    });
  }

  /**
   * Handle state transitions based on intent
   */
  private async handleStateTransition(
    context: ConversationContext,
    intent: any
  ): Promise<ConversationContext> {
    // State transitions based on intent and current state
    switch (context.state) {
      case ConversationState.INIT:
        if (intent === 'PLAN_TRIP' && context.preferences.city) {
          return this.stateManager.transitionTo(
            context,
            ConversationState.COLLECTING_PREFS,
            'User started trip planning'
          );
        }
        break;

      case ConversationState.COLLECTING_PREFS:
        if (this.stateManager.canProceedToConfirmation(context)) {
          return this.stateManager.transitionTo(
            context,
            ConversationState.CONFIRMING,
            'All required fields collected'
          );
        }
        break;

      case ConversationState.PLANNED:
        if (intent === 'EDIT_ITINERARY') {
          return this.stateManager.transitionTo(
            context,
            ConversationState.EDITING,
            'User wants to edit itinerary'
          );
        }
        if (intent === 'EXPLAIN') {
          return this.stateManager.transitionTo(
            context,
            ConversationState.EXPLAINING,
            'User asking for explanation'
          );
        }
        break;

      case ConversationState.EDITING:
        // Stay in editing or transition back to planned (handled by tool orchestration)
        break;

      case ConversationState.EXPLAINING:
        // Can transition back to planned after explanation
        break;
    }

    return context;
  }

  /**
   * Save transcript to database
   */
  private async saveTranscript(
    tripId: string,
    role: 'user' | 'assistant',
    content: string
  ): Promise<void> {
    const { error } = await this.supabase.from('transcripts').insert({
      trip_id: tripId,
      role,
      content,
      timestamp: new Date().toISOString(),
    });

    if (error) {
      console.error('Failed to save transcript:', error);
    }
  }

  /**
   * Register an MCP tool
   * Tools must be registered before they can be used
   */
  registerTool(tool: any): void {
    this.toolOrchestrator.registerTool(tool);
  }
}
