/**
 * PolicyGuards
 * 
 * Enforces system rules and policies.
 * 
 * Responsibilities:
 * - Prevent LLM from calling tools directly
 * - Validate tool call decisions
 * - Ensure state transitions are valid
 * - Enforce data grounding requirements
 * 
 * Rules Enforced:
 * - LLM cannot call MCP tools (only orchestrator can)
 * - Itineraries must come from MCP tools, not LLM generation
 * - Travel tips must come from RAG, not LLM knowledge
 * - POIs must map to OpenStreetMap records
 */

import {
  ConversationContext,
  ToolCallDecision,
  ToolCallResult,
  PolicyCheck,
  ComposedResponse,
} from './types';

export class PolicyGuards {
  /**
   * Check if a tool call decision is allowed
   * 
   * This prevents unauthorized tool calls.
   * Only the orchestrator should make tool call decisions.
   */
  validateToolCallDecision(decision: ToolCallDecision): PolicyCheck {
    // Tool calls must have a reason
    if (decision.shouldCall && !decision.reason) {
      return {
        allowed: false,
        reason: 'Tool call decision must include a reason',
        alternative: 'Add reasoning to tool call decision',
      };
    }

    // Tool name must be specified if calling
    if (decision.shouldCall && !decision.toolName) {
      return {
        allowed: false,
        reason: 'Tool name must be specified for tool calls',
        alternative: 'Specify tool name in decision',
      };
    }

    return { allowed: true };
  }

  /**
   * Validate that itinerary was generated by MCP tool, not LLM
   * 
   * CRITICAL RULE: LLM must NEVER directly generate itineraries.
   * All itineraries must come from MCP tools.
   */
  validateItinerarySource(toolCalls: ToolCallResult[]): PolicyCheck {
    // Check if itinerary_builder tool was called
    const itineraryToolCalled = toolCalls.some(
      (call) => call.toolName === 'itinerary_builder'
    );

    if (!itineraryToolCalled) {
      return {
        allowed: false,
        reason: 'Itinerary must be generated by itinerary_builder MCP tool',
        alternative: 'Call itinerary_builder tool before returning itinerary',
      };
    }

    // Check if tool call was successful
    const successfulCall = toolCalls.find(
      (call) => call.toolName === 'itinerary_builder' && call.output.success
    );

    if (!successfulCall) {
      return {
        allowed: false,
        reason: 'Itinerary builder tool call failed',
        alternative: 'Fix tool call error before proceeding',
      };
    }

    return { allowed: true };
  }

  /**
   * Validate that travel tips have RAG citations
   * 
   * RULE: Travel tips and explanations must come from RAG sources.
   * If RAG data is missing, system must say so explicitly.
   */
  validateRAGGrounded(response: ComposedResponse, context: ConversationContext): PolicyCheck {
    // If explaining, must have citations
    if (context.state === 'EXPLAINING') {
      if (!response.citations || response.citations.length === 0) {
        // Check if response explicitly states data is missing
        const missingDataPattern = /(?:don't have|missing|unavailable|no data|no information)/i;
        if (!missingDataPattern.test(response.text)) {
          return {
            allowed: false,
            reason: 'Explanations must cite RAG sources or explicitly state data is missing',
            alternative: 'Add citations or state that data is unavailable',
          };
        }
      }
    }

    return { allowed: true };
  }

  /**
   * Validate that POIs map to OpenStreetMap records
   * 
   * RULE: POIs must map to OpenStreetMap (Overpass API) records.
   * This is checked when POI search tool returns results.
   */
  validatePOIMapping(toolCalls: ToolCallResult[]): PolicyCheck {
    const poiSearchCall = toolCalls.find((call) => call.toolName === 'poi_search');

    if (!poiSearchCall) {
      // PHASE 4: POI search is disabled - this is expected and allowed
      // No POI search, so no validation needed
      return { allowed: true };
    }

    if (!poiSearchCall.output.success) {
      // PHASE 4: POI search is disabled - if it was called and failed, that's expected
      // Don't fail the policy check - just log it
      console.warn('POI search was called but failed (expected - POI search is disabled)');
      return { allowed: true }; // Allow it - POI search is optional
    }

    // Check if POIs have OSM IDs or references
    const pois = poiSearchCall.output.data?.pois || [];
    const unmappedPOIs = pois.filter((poi: any) => !poi.osmId && !poi.osmReference);

    if (unmappedPOIs.length > 0) {
      return {
        allowed: false,
        reason: `Found ${unmappedPOIs.length} POIs without OpenStreetMap mapping`,
        alternative: 'Ensure all POIs have OSM IDs or references',
      };
    }

    return { allowed: true };
  }

  /**
   * Validate that LLM is not attempting to call tools
   * 
   * CRITICAL RULE: LLM cannot call MCP tools directly.
   * This checks LLM responses for tool call attempts.
   */
  validateNoDirectToolCalls(llmResponse: string): PolicyCheck {
    // Check for tool call patterns in LLM response
    const toolCallPatterns = [
      /call.*tool/i,
      /use.*mcp/i,
      /execute.*tool/i,
      /tool.*function/i,
    ];

    const hasToolCallAttempt = toolCallPatterns.some((pattern) =>
      pattern.test(llmResponse)
    );

    if (hasToolCallAttempt) {
      return {
        allowed: false,
        reason: 'LLM attempted to call tools directly (not allowed)',
        alternative: 'LLM should only generate responses, orchestrator handles tool calls',
      };
    }

    return { allowed: true };
  }

  /**
   * Validate state transition
   * 
   * Ensures state transitions follow FSM rules.
   */
  validateStateTransition(
    from: string,
    to: string,
    _context: ConversationContext
  ): PolicyCheck {
    // This is a basic check - detailed validation is in ConversationStateManager
    if (from === to) {
      return { allowed: true }; // Staying in same state is always allowed
    }

    // State transitions are validated by ConversationStateManager
    // This is just a policy-level check
    return { allowed: true };
  }

  /**
   * Comprehensive policy check before returning response
   * 
   * Runs all relevant policy checks before finalizing response.
   */
  validateResponse(
    response: ComposedResponse,
    context: ConversationContext,
    toolCalls: ToolCallResult[]
  ): PolicyCheck {
    // Check itinerary source
    if (context.state === 'PLANNED' || context.state === 'EDITING') {
      const itineraryCheck = this.validateItinerarySource(toolCalls);
      if (!itineraryCheck.allowed) {
        return itineraryCheck;
      }
    }

    // Check RAG grounding
    const ragCheck = this.validateRAGGrounded(response, context);
    if (!ragCheck.allowed) {
      return ragCheck;
    }

    // Check POI mapping
    const poiCheck = this.validatePOIMapping(toolCalls);
    if (!poiCheck.allowed) {
      return poiCheck;
    }

    return { allowed: true };
  }
}

